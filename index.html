<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fruit Predictor + Push</title>

  <!-- PWA bits (required on iOS for Home Screen install + push) -->
  <link rel="manifest" href="manifest.webmanifest" />

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7fb; color: #111; min-height: 100vh; }
    .wrap { max-width: 720px; margin: 0 auto; padding: 24px; }
    .card {
      background: white; border-radius: 16px; padding: 20px;
      box-shadow: 0 6px 18px rgba(0,0,0,.08);
      user-select: none;
    }
    h1 { font-size: 22px; margin: 0 0 12px; }
    p { margin: 8px 0; line-height: 1.4; }

    /* Bottom bar (moved from top to bottom, per request) */
    .bottombar{
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px; margin-top: 14px;
    }
    .bottombar .left{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .status { font-size: 13px; color:#444; }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin: 16px 0 14px;
    }
    .item {
      background: #f2f4ff;
      border: 1px solid #e1e6ff;
      border-radius: 12px;
      padding: 10px;
      text-align: center;
      font-weight: 600;
    }
    .btnRow { display:flex; justify-content:center; margin-top: 14px; gap:10px; flex-wrap:wrap; }
    button {
      border: 0; border-radius: 12px; padding: 12px 16px;
      font-size: 16px; font-weight: 700; cursor: pointer;
      background:#111; color:#fff;
    }
    button.secondary { background:#2f2f2f; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .hint {
      font-size: 13px;
      color:#444;
      margin-top: 10px;
      text-align: center;
    }

    .result {
      font-size: 28px;
      font-weight: 900;
      text-align: center;
      padding: 16px;
      background: #fff7d6;
      border: 1px solid #ffe08a;
      border-radius: 14px;
      margin-top: 14px;
    }

    /* NOTE:
      We removed the custom swipe-to-advance UX and replaced it with a "Next" button.
      Keeping default touch behavior is fine (no need to capture horizontal swipes).
    */
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Main game container -->
    <div class="card" id="app"></div>

    <!-- Bottom bar (EN + status) moved below the main game UI -->
    <div class="bottombar" aria-label="Notifications and status">
      <div class="left">
        <button id="btnSubscribe" class="secondary" type="button">EN</button>
        <span id="status" class="status"></span>
      </div>
    </div>
  </div>

  <script>
    /**********************************************************************
     * 1) PUSH NOTIFICATION LOGIC
     **********************************************************************/

    // Cloudflare Worker base URL (backend)
    const API_BASE = "https://push-worker.watch-push-worker.workers.dev";

    // VAPID PUBLIC key (for Push API)
    const VAPID_PUBLIC_KEY = "BBXwQxs50IT89DLPGs-QbSUYnRsJFNcShDstN4GIWwqLeGbHwT-3O3C1xRh2hH7TgablUAo69pESfB2Rk4ObZfQ";

    // UI refs for the (now bottom) bar
    const statusEl = document.getElementById("status");
    const btnSubscribe = document.getElementById("btnSubscribe");

    // Helper: update status text
    function setStatus(s) { statusEl.textContent = s; }

    // Helper: convert VAPID key format required by pushManager.subscribe()
    function urlBase64ToUint8Array(base64String) {
      const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
      return outputArray;
    }

    // Ensure we have a service worker registered (required for push)
    async function ensureServiceWorker() {
      if (!("serviceWorker" in navigator)) throw new Error("No serviceWorker support");
      const reg = await navigator.serviceWorker.register("./sw.js", { scope: "./" });
      return reg;
    }

    // Subscribe this device to push notifications and store device credentials
    async function subscribe() {
      setStatus("Registering…");
      const reg = await ensureServiceWorker();

      setStatus("Requesting permission…");
      const perm = await Notification.requestPermission();
      if (perm !== "granted") throw new Error("Notification permission not granted");

      setStatus("Subscribing…");
      const sub = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
      });

      setStatus("Saving subscription…");
      const r = await fetch(API_BASE + "/subscribe", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ subscription: sub }),
      });
      if (!r.ok) throw new Error("Backend /subscribe failed");
      const data = await r.json();

      // Persist on-device so future sessions can send without re-subscribing
      localStorage.setItem("deviceId", data.deviceId);
      localStorage.setItem("deviceSecret", data.deviceSecret);

      setStatus("✅ Ready");
    }

    // Send a push message to this device (uses stored deviceId + deviceSecret)
    async function sendPush(message) {
      const deviceId = localStorage.getItem("deviceId");
      const deviceSecret = localStorage.getItem("deviceSecret");

      if (!deviceId || !deviceSecret) {
        setStatus("Enable notifications to receive the prediction");
        return { ok: false, reason: "not_subscribed" };
      }
      if (!message || !String(message).trim()) return { ok: false, reason: "empty_message" };

      setStatus("Sending…");
      setStatus(" ");
      const r = await fetch(API_BASE + "/send", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ deviceId, deviceSecret, message: String(message).trim() }),
      });
      if (!r.ok) {
        const msg = "Backend /send failed";
        setStatus("❌ " + msg);
        return { ok: false, reason: "send_failed" };
      }
      setStatus("✅ Sent");
      setStatus(" ");
      return { ok: true };
    }

    // Subscribe button handler
    btnSubscribe.addEventListener("click", () => subscribe().catch(e => {
      console.error(e);
      setStatus("❌ " + e.message);
    }));

    // Initial status message
    setStatus(localStorage.getItem("deviceId") ? "Ready (already subscribed)" : "Not subscribed");

    /**********************************************************************
     * 2) FRUIT GAME LOGIC
     *
     * Core idea:
     * - We assign each fruit a unique 4-bit code (0..15).
     * - Each question page represents one bit position (0..3).
     * - The page shows the subset of fruits where that bit is 1.
     * - The player's YES/NO answers reconstruct the 4-bit code.
     * - That code maps back to the chosen fruit.
     *
     * Requested change:
     * - Under-the-hood meaning of time:
     *     * Waiting 10s+ on a page means the fruit is NOT in that subset (NO).
     *     * Answering within 10s means the fruit IS in that subset (YES).
     *   (This is inverted from the previous version.)
     *
     * UX change:
     * - Replace swipe-to-advance with a "Next" button.
     **********************************************************************/

    // Expanded from 12 to 16 fruits (4-bit space => 16 unique values)
    const fruits = [
      "Apple", "Banana", "Cherry", "Date",
      "Grape", "Kiwi", "Lemon", "Mango",
      "Orange", "Peach", "Pear", "Plum",
      "Pineapple", "Strawberry", "Watermelon", "Apricot"
    ];

    // 4 pages (bits 0..3) can represent up to 16 fruits
    const TOTAL_PAGES = 4;

    // Timing rule:
    // - <= 10s => YES (fruit IS in the subset)
    // - > 10s  => NO  (fruit is NOT in the subset)
    const YES_THRESHOLD_SECONDS = 10;

    // Map fruit -> numeric code (0..15). Order in the array defines the code.
    const fruitCodes = new Map(fruits.map((f, i) => [f, i]));

    // State variables
    let pageIndex = -1;   // -1 = intro, 0..3 = questions, 4 = result
    let answerCode = 0;   // reconstructed 4-bit number from user answers
    let pageStartMs = 0;  // used for timing-based answer logic

    // App root
    const app = document.getElementById("app");

    /**
     * Return the subset of fruits for a given bit position.
     * Example: bitIndex=0 returns fruits whose code has LSB set to 1.
     */
    function subsetForBit(bitIndex) {
      return fruits.filter(f => ((fruitCodes.get(f) >> bitIndex) & 1) === 1);
    }

    /** Start/reset timer when a question page is shown */
    function startPageTimer() {
      pageStartMs = Date.now();
    }

    /**
     * Convert elapsed time into a YES/NO for the current page.
     * Requested inversion implemented here:
     * - <= threshold => YES
     * - > threshold  => NO
     */
    function computeYesNoFromTime() {
      const elapsedSeconds = (Date.now() - pageStartMs) / 1000;
      const isYes = elapsedSeconds <= YES_THRESHOLD_SECONDS;
      return { isYes, elapsedSeconds };
    }

    /**********************************************************************
     * 3) RENDERING (INTRO / QUESTIONS / RESULT)
     **********************************************************************/

    function renderIntro() {
      // Reset state
      pageIndex = -1;
      answerCode = 0;

      // Build the intro UI
      app.innerHTML = `
        <h1>Think of a Fruit</h1>
        <p>Pick <b>one</b> fruit from this list and keep it in your head.</p>

        <div class="grid" aria-label="Fruit options">
          ${fruits.map(f => `<div class="item">${f}</div>`).join("")}
        </div>

        <div class="btnRow">
          <button id="startBtn" type="button">Start</button>
        </div>
      `;

      // Start the first question page
      document.getElementById("startBtn").onclick = () => {
        pageIndex = 0;
        answerCode = 0;
        renderQuestion();
      };
    }

    function renderQuestion() {
      const bitIndex = pageIndex;
      const subset = subsetForBit(bitIndex);

      app.innerHTML = `
        <h1>Question ${pageIndex + 1} of ${TOTAL_PAGES}</h1>
        <p>Is your fruit in this subset?</p>

        <div class="grid">
          ${subset.map(f => `<div class="item">${f}</div>`).join("")}
        </div>

        <div class="btnRow">
          <button id="nextBtn" type="button">Next</button>
        </div>

        <div class="hint">
          Tip: Press <b>Next</b> within ${YES_THRESHOLD_SECONDS}s for <b>YES</b>.
          Wait more than ${YES_THRESHOLD_SECONDS}s for <b>NO</b>.
        </div>
      `;

      // Start timing this question as soon as it renders
      startPageTimer();

      // Button-driven progression (replaces swipe)
      document.getElementById("nextBtn").onclick = handleAdvance;
    }

    /**
     * Advances game state by one page.
     * - Reads YES/NO based on elapsed time.
     * - If YES, sets the corresponding bit in answerCode.
     * - Renders next question or result.
     */
    function handleAdvance() {
      if (pageIndex < 0 || pageIndex >= TOTAL_PAGES) return;

      const { isYes } = computeYesNoFromTime();
      if (isYes) answerCode |= (1 << pageIndex);

      pageIndex++;

      if (pageIndex < TOTAL_PAGES) renderQuestion();
      else renderResult();
    }

    function renderResult() {
      const predicted = fruits.find(f => fruitCodes.get(f) === answerCode) || "No match";
      const prediction = predicted; // value sent via push

      app.innerHTML = `
        <h1>Prediction</h1>
        <p>I think you were thinking of:</p>
        <div class="result">${predicted}</div>

        <div class="btnRow">
          <button id="restartBtn" type="button">Play Again</button>
        </div>
      `;

      // Trigger push automatically upon reaching the prediction page.
      // (If not subscribed yet, status tells the user to enable notifications.)
      sendPush(prediction).catch(e => {
        console.error("Send failed:", e);
        setStatus("❌ " + String(e && e.message ? e.message : e));
      });

      document.getElementById("restartBtn").onclick = renderIntro;
    }

    /**********************************************************************
     * 4) INIT
     **********************************************************************/
    renderIntro();
  </script>
</body>
</html>
